## [513. Find Bottom Left Tree Value](https://leetcode.cn/problems/find-bottom-left-tree-value/)
要注意回溯，另外主函数起始值0，1都可以甚至100都可以但是深度1开始似乎更合理,没有中节点的操作
递归遍历方法
```CPP
class Solution {
private:
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode* node,int depth){
        if(node->left==NULL&&node->right==NULL){
            if(depth>maxDepth){
                maxDepth = depth;
                result = node->val;
            }
        }
        if(node->left!=NULL){
            depth++;
            traversal(node->left, depth);
            depth--;
        }
        if(node->right!=NULL){
            depth++;
            traversal(node->right,depth);
            depth--;
        }
    }
public:
    int findBottomLeftValue(TreeNode* root) {
        traversal(root,1);
        return result;
    }
};
```

层序遍历方法
```CPP
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        vector<vector<int>> mv;
        queue<TreeNode*> que;
        if(root!=NULL) que.push(root);
        while(que.size()!=0){
            int size = que.size();
            vector<int> result;
            while(size--){
                TreeNode* node = que.front();
                que.pop();
                //cout<<node->val<<endl;
                result.push_back(node->val); 
                if(node->left!=NULL) que.push(node->left);
                if(node->right!=NULL) que.push(node->right);
            }
            mv.push_back(result);
        }
        return mv.back().front();
    }
};
```

## [112. Path Sum](https://leetcode.cn/problems/path-sum/)
用减的方法和0去比较，另外一开始就把root->val减掉防止只有一个根节点和target相同的特殊情况
![image](https://github.com/YunfanLing/YunfanLing.github.io/assets/102476857/74e7825c-0d11-4cca-a7d5-373f1a446f73)
```CPP
class Solution {
public:
    bool traversal(TreeNode*node,int count){
        if(node->left==NULL&&node->right==NULL){
            if(count==0) return true;
            else return false;
        }
        bool leftPath=false;
        bool rightPath=false;
        if(node->left!=NULL){
            count -=node->left->val;
            //if(traversal(node->left, count)) return true;
            leftPath = traversal(node->left,count);
            count +=node->left->val;
        }
        if(node->right!=NULL){
            count -=node->right->val;
            //if(traversal(node->right,count)) return true;
            rightPath = traversal(node->right,count);
            count +=node->right->val;
        }
        //return false;
        return leftPath||rightPath;
    }
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root==NULL) return false;
        return traversal(root,targetSum-root->val);//在这里输入时就把root减了，避免只有一个root node而target值和root一样的情况
    }
};
```
